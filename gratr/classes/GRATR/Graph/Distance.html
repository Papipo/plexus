<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: GRATR::Graph::Distance</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">GRATR::Graph::Distance</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/gratr/digraph_distance_rb.html">
                lib/gratr/digraph_distance.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000322">bellman_ford_moore</a>&nbsp;&nbsp;
      <a href="#M000321">dijkstras_algorithm</a>&nbsp;&nbsp;
      <a href="#M000323">floyd_warshall</a>&nbsp;&nbsp;
      <a href="#M000320">shortest_path</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000322" class="method-detail">
        <a name="M000322"></a>

        <div class="method-heading">
          <a href="#M000322" class="method-signature">
          <span class="method-name">bellman_ford_moore</span><span class="method-args">(start, weight = nil, zero = 0)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Algorithm from Jorgen Band-Jensen and Gregory Gutin,
_DIGRAPHS:_Theory,_Algorithms_and_Applications, pg 56-58
</p>
<p>
Finds the distances from a given vertex s in a weighted digraph to the rest
of the vertices, provided the graph has no negative cycle. If no negative
weights exist, then <a href="Distance.html#M000321">dijkstras_algorithm</a>
is more efficient in time and space. Also if the graph is acyclic, use the
<a href="Distance.html#M000320">shortest_path</a> algorithm.
</p>
<p>
weight can be a Proc, or anything else is accessed using the [] for the
</p>
<pre>
    the label or it defaults to using
    the value stored in the label for the Arc. If it is a Proc it will
    pass the edge to the proc and use the resulting value.
</pre>
<p>
zero is used for math system with a different definition of zero
</p>
<p>
Returns a hash with the key being a vertex and the value being the
distance. A missing vertex from the hash is an infinite distance
</p>
<p>
O(nm) complexity
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000322-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000322-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/digraph_distance.rb, line 117</span>
117:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">bellman_ford_moore</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">weight</span> = <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">zero</span> = <span class="ruby-value">0</span>)
118:         <span class="ruby-identifier">distance</span> = { <span class="ruby-identifier">start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">zero</span> }; <span class="ruby-identifier">path</span> = {}
119:         <span class="ruby-value">2</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">vertices</span>.<span class="ruby-identifier">size</span>) <span class="ruby-keyword kw">do</span>
120:           <span class="ruby-identifier">edges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
121:             <span class="ruby-identifier">u</span>,<span class="ruby-identifier">v</span> = <span class="ruby-identifier">e</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">e</span>[<span class="ruby-value">1</span>]
122:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">u</span>].<span class="ruby-identifier">nil?</span>
123:               <span class="ruby-identifier">c</span> = <span class="ruby-identifier">cost</span>(<span class="ruby-identifier">u</span>, <span class="ruby-identifier">v</span>, <span class="ruby-identifier">weight</span>)<span class="ruby-operator">+</span><span class="ruby-identifier">distance</span>[<span class="ruby-identifier">u</span>]
124:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">v</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">v</span>]
125:                 <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">c</span>
126:                 <span class="ruby-identifier">path</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">u</span>
127:               <span class="ruby-keyword kw">end</span> 
128:             <span class="ruby-keyword kw">end</span>        
129:           <span class="ruby-keyword kw">end</span>
130:         <span class="ruby-keyword kw">end</span>; [<span class="ruby-identifier">distance</span>, <span class="ruby-identifier">path</span>]
131:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000321" class="method-detail">
        <a name="M000321"></a>

        <div class="method-heading">
          <a href="#M000321" class="method-signature">
          <span class="method-name">dijkstras_algorithm</span><span class="method-args">(s, weight = nil, zero = 0)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Algorithm from Jorgen Band-Jensen and Gregory Gutin,
_DIGRAPHS:_Theory,_Algorithms_and_Applications, pg 53-54
</p>
<p>
Finds the distances from a given vertex s in a weighted digraph to the rest
of the vertices, provided all the weights of arcs are non-negative. If
negative arcs exist in the graph, two basic options exist, 1) modify all
weights to be positive by using an offset, or 2) use the <a
href="Distance.html#M000322">bellman_ford_moore</a> algorithm. Also if the
graph is acyclic, use the <a href="Distance.html#M000320">shortest_path</a>
algorithm.
</p>
<p>
weight can be a Proc, or anything else is accessed using the [] for the
</p>
<pre>
    the label or it defaults to using
    the value stored in the label for the Arc. If it is a Proc it will
    pass the edge to the proc and use the resulting value.
</pre>
<p>
zero is used for math system with a different definition of zero
</p>
<p>
Returns a hash with the key being a vertex and the value being the
distance. A missing vertex from the hash is an infinite distance
</p>
<p>
O(n*log(n) + m) complexity
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000321-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000321-source">
<pre>
    <span class="ruby-comment cmt"># File lib/gratr/digraph_distance.rb, line 82</span>
82:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">dijkstras_algorithm</span>(<span class="ruby-identifier">s</span>, <span class="ruby-identifier">weight</span> = <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">zero</span> = <span class="ruby-value">0</span>)
83:         <span class="ruby-identifier">q</span> = <span class="ruby-identifier">vertices</span>; <span class="ruby-identifier">distance</span> = { <span class="ruby-identifier">s</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">zero</span> }; <span class="ruby-identifier">path</span> = {}
84:         <span class="ruby-keyword kw">while</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">empty?</span>
85:           <span class="ruby-identifier">v</span> = (<span class="ruby-identifier">q</span> <span class="ruby-operator">&amp;</span> <span class="ruby-identifier">distance</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-keyword kw">nil</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">k</span><span class="ruby-operator">|</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">a</span>.<span class="ruby-identifier">nil?</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">distance</span>[<span class="ruby-identifier">a</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">k</span>]) <span class="ruby-operator">?</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">k</span>} 
86:           <span class="ruby-identifier">q</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">v</span>)
87:           (<span class="ruby-identifier">q</span> <span class="ruby-operator">&amp;</span> <span class="ruby-identifier">adjacent</span>(<span class="ruby-identifier">v</span>)).<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">u</span><span class="ruby-operator">|</span>
88:             <span class="ruby-identifier">c</span> = <span class="ruby-identifier">cost</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">u</span>,<span class="ruby-identifier">weight</span>)
89:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">u</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">u</span>] <span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">c</span><span class="ruby-operator">+</span><span class="ruby-identifier">distance</span>[<span class="ruby-identifier">v</span>])
90:               <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">u</span>] = <span class="ruby-identifier">c</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">distance</span>[<span class="ruby-identifier">v</span>]
91:               <span class="ruby-identifier">path</span>[<span class="ruby-identifier">u</span>] = <span class="ruby-identifier">v</span>
92:             <span class="ruby-keyword kw">end</span>
93:           <span class="ruby-keyword kw">end</span>
94:         <span class="ruby-keyword kw">end</span>; [<span class="ruby-identifier">distance</span>, <span class="ruby-identifier">path</span>]
95:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000323" class="method-detail">
        <a name="M000323"></a>

        <div class="method-heading">
          <a href="#M000323" class="method-signature">
          <span class="method-name">floyd_warshall</span><span class="method-args">(weight=nil, zero=0)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
This uses the Floyd-Warshall algorithm to efficiently find and record
shortest paths at the same time as establishing the costs for all vertices
in a graph. See, S.Skiena, &quot;The Algorithm Design Manual&quot;,
Springer Verlag, 1998 for more details.
</p>
<p>
Returns a pair of matrices and a hash of delta values. The matrices will be
indexed by two vertices and are implemented as a <a
href="../../Hash.html">Hash</a> of Hashes. The first matrix is the cost,
the second matrix is the shortest path spanning tree. The delta (difference
of number of in edges and out edges) is indexed by vertex.
</p>
<p>
weight specifies how an edge weight is determined, if it&#8217;s a Proc the
<a href="../Arc.html">Arc</a> is passed to it, if it&#8217;s nil it will
just use the value in the label for the <a href="../Arc.html">Arc</a>,
otherwise the weight is determined by applying the [] operator to the value
in the label for the <a href="../Arc.html">Arc</a>
</p>
<p>
zero defines the zero value in the math system used. Defaults of course, to
0. This allows for no assumptions to be made about the math system and
fully functional duck typing.
</p>
<p>
O(n^3) complexity in time.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000323-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000323-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/digraph_distance.rb, line 156</span>
156:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">floyd_warshall</span>(<span class="ruby-identifier">weight</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">zero</span>=<span class="ruby-value">0</span>)
157:         <span class="ruby-identifier">c</span>     = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">h</span>,<span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>}
158:         <span class="ruby-identifier">path</span>  = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">h</span>,<span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>}
159:         <span class="ruby-identifier">delta</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">h</span>,<span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-value">0</span>}
160:         <span class="ruby-identifier">edges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> 
161:           <span class="ruby-identifier">delta</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
162:           <span class="ruby-identifier">delta</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
163:           <span class="ruby-identifier">path</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>][<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>      
164:           <span class="ruby-identifier">c</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>][<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] = <span class="ruby-identifier">cost</span>(<span class="ruby-identifier">e</span>, <span class="ruby-identifier">weight</span>)
165:         <span class="ruby-keyword kw">end</span>
166:         <span class="ruby-identifier">vertices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
167:           <span class="ruby-identifier">vertices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
168:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">k</span>]
169:               <span class="ruby-identifier">vertices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
170:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">k</span>][<span class="ruby-identifier">j</span>] <span class="ruby-operator">&amp;&amp;</span> 
171:                   (<span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] <span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">k</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">k</span>][<span class="ruby-identifier">j</span>]))
172:                   <span class="ruby-identifier">path</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] = <span class="ruby-identifier">path</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">k</span>]
173:                   <span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] = <span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">k</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">k</span>][<span class="ruby-identifier">j</span>]
174:                   <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">j</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">c</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">zero</span>
175:                 <span class="ruby-keyword kw">end</span>
176:               <span class="ruby-keyword kw">end</span>
177:             <span class="ruby-keyword kw">end</span>  
178:           <span class="ruby-keyword kw">end</span>
179:         <span class="ruby-keyword kw">end</span>
180:         [<span class="ruby-identifier">c</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">delta</span>]
181:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000320" class="method-detail">
        <a name="M000320"></a>

        <div class="method-heading">
          <a href="#M000320" class="method-signature">
          <span class="method-name">shortest_path</span><span class="method-args">(start, weight=nil, zero=0)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Shortest path from Jorgen Band-Jensen and Gregory Gutin,
_DIGRAPHS:_Theory,_Algorithms_and_Applications, pg 53-54
</p>
<p>
Requires that the graph be acyclic. If the graph is not acyclic, then see
<a href="Distance.html#M000321">dijkstras_algorithm</a> or <a
href="Distance.html#M000322">bellman_ford_moore</a> for possible solutions.
</p>
<p>
start is the starting vertex weight can be a Proc, or anything else is
accessed using the [] for the
</p>
<pre>
    the label or it defaults to using
    the value stored in the label for the Arc. If it is a Proc it will
    pass the edge to the proc and use the resulting value.
</pre>
<p>
zero is used for math system with a different definition of zero
</p>
<p>
Returns a hash with the key being a vertex and the value being the
distance. A missing vertex from the hash is an infinite distance
</p>
<p>
Complexity O(n+m)
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000320-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000320-source">
<pre>
    <span class="ruby-comment cmt"># File lib/gratr/digraph_distance.rb, line 50</span>
50:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">shortest_path</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">weight</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">zero</span>=<span class="ruby-value">0</span>)
51:         <span class="ruby-identifier">dist</span> = {<span class="ruby-identifier">start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">zero</span>}; <span class="ruby-identifier">path</span> = {}
52:         <span class="ruby-identifier">topsort</span>(<span class="ruby-identifier">start</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">vi</span><span class="ruby-operator">|</span>
53:           <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">vi</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">start</span>
54:           <span class="ruby-identifier">dist</span>[<span class="ruby-identifier">vi</span>],<span class="ruby-identifier">path</span>[<span class="ruby-identifier">vi</span>] = <span class="ruby-identifier">adjacent</span>(<span class="ruby-identifier">vi</span>, <span class="ruby-identifier">:direction</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:in</span>).<span class="ruby-identifier">map</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">vj</span><span class="ruby-operator">|</span>
55:             [<span class="ruby-identifier">dist</span>[<span class="ruby-identifier">vj</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">cost</span>(<span class="ruby-identifier">vj</span>,<span class="ruby-identifier">vi</span>,<span class="ruby-identifier">weight</span>), <span class="ruby-identifier">vj</span>] 
56:           <span class="ruby-keyword kw">end</span>.<span class="ruby-identifier">min</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>[<span class="ruby-value">0</span>]}
57:         <span class="ruby-keyword kw">end</span>; 
58:         <span class="ruby-identifier">dist</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">vertices</span>.<span class="ruby-identifier">size</span> <span class="ruby-value">? </span>[<span class="ruby-identifier">dist</span>,<span class="ruby-identifier">path</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>
59:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>