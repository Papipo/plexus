<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: GRATR::Graph::Search</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">GRATR::Graph::Search</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/gratr/search_rb.html">
                lib/gratr/search.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000313">acyclic?</a>&nbsp;&nbsp;
      <a href="#M000310">astar</a>&nbsp;&nbsp;
      <a href="#M000311">best_first</a>&nbsp;&nbsp;
      <a href="#M000301">bfs</a>&nbsp;&nbsp;
      <a href="#M000305">bfs_spanning_forest</a>&nbsp;&nbsp;
      <a href="#M000308">bfs_tree_from_vertex</a>&nbsp;&nbsp;
      <a href="#M000314">cyclic?</a>&nbsp;&nbsp;
      <a href="#M000302">dfs</a>&nbsp;&nbsp;
      <a href="#M000304">dfs_spanning_forest</a>&nbsp;&nbsp;
      <a href="#M000307">dfs_tree_from_vertex</a>&nbsp;&nbsp;
      <a href="#M000309">lexicograph_bfs</a>&nbsp;&nbsp;
      <a href="#M000303">spanning_forest</a>&nbsp;&nbsp;
      <a href="#M000312">topsort</a>&nbsp;&nbsp;
      <a href="#M000306">tree_from_vertex</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Class <a href="Search/LexicographicQueue.html" class="link">GRATR::Graph::Search::LexicographicQueue</a><br />

    </div>


    <div id="aliases-list">
      <h3 class="section-bar">External Aliases</h3>

      <div class="name-list">
                        <table summary="aliases">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">method_missing</td>
          <td>-></td>
          <td class="context-item-value">pre_search_method_missing</td>
        </tr>
                        </table>
      </div>
    </div>


      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000313" class="method-detail">
        <a name="M000313"></a>

        <div class="method-heading">
          <a href="#M000313" class="method-signature">
          <span class="method-name">acyclic?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if a graph contains no cycles, false otherwise
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000313-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000313-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 414</span>
414:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">acyclic?</span>() <span class="ruby-identifier">topsort</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">size</span>; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000310" class="method-detail">
        <a name="M000310"></a>

        <div class="method-heading">
          <a href="#M000310" class="method-signature">
          <span class="method-name">astar</span><span class="method-args">(start, goal, func, options, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
A* Heuristic best first search
</p>
<p>
start is the starting vertex for the search
</p>
<p>
func is a Proc that when passed a vertex returns the heuristic
</p>
<pre>
  weight of sending the path through that node. It must always
  be equal to or less than the true cost
</pre>
<p>
options are mostly callbacks passed in as a hash, the default block is
:discover_vertex and weight is assumed to be the label for the <a
href="../Arc.html">Arc</a>. The following options are valid, anything else
is ignored.
</p>
<ul>
<li>:weight =&gt; can be a Proc, or anything else is accessed using the [] for
the

<pre>
  the label or it defaults to using
  the value stored in the label for the Arc. If it is a Proc it will
  pass the edge to the proc and use the resulting value.
</pre>
</li>
<li>:discover_vertex =&gt; Proc invoked when a vertex is first discovered and
is added to the open list.

</li>
<li>:examine_vertex =&gt; Proc invoked when a vertex is popped from the queue
(i.e., it has the lowest cost on the open list).

</li>
<li>:examine_edge =&gt; Proc invoked on each out-edge of a vertex immediately
after it is examined.

</li>
<li>:edge_relaxed =&gt; Proc invoked on edge (u,v) if d[u] + w(u,v) &lt; d[v].

</li>
<li>:edge_not_relaxed=&gt; Proc invoked if the edge is not relaxed (see above).

</li>
<li>:black_target =&gt; Proc invoked when a vertex that is on the closed

<pre>
  list is &quot;rediscovered&quot; via a more efficient path, and is re-added
  to the OPEN list.
</pre>
</li>
<li>:finish_vertex =&gt; Proc invoked on a vertex when it is added to the

<pre>
  closed list, which happens after all of its out edges have been
  examined.
</pre>
</li>
</ul>
<p>
Returns array of nodes in path, or calls block on all nodes, upon failure
returns nil
</p>
<p>
Can also be called like astar_examine_edge {|e| &#8230; } or
astar_edge_relaxed {|e| &#8230; } for any of the callbacks
</p>
<p>
The criteria for expanding a vertex on the open list is that it has the
lowest f(v) = g(v) + h(v) value of all vertices on open.
</p>
<p>
The time complexity of A* depends on the heuristic. It is exponential in
the worst case, but is polynomial when the heuristic function h meets the
following condition: |h(x) - h*(x)| &lt; O(log h*(x)) where h* is the
optimal heuristic, i.e. the exact cost to get from x to the goal.
</p>
<p>
Also see: <a
href="http://en.wikipedia.org/wiki/A-star_search_algorithm">en.wikipedia.org/wiki/A-star_search_algorithm</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000310-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000310-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 253</span>
253:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">astar</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">goal</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
254:         <span class="ruby-identifier">options</span>.<span class="ruby-identifier">instance_eval</span> <span class="ruby-value str">&quot;def handle_callback(sym,u) self[sym].call(u) if self[sym]; end&quot;</span>
255:          
256:         <span class="ruby-comment cmt"># Initialize</span>
257:         <span class="ruby-identifier">d</span> = { <span class="ruby-identifier">start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> }
258:         
259:         <span class="ruby-identifier">color</span> = {<span class="ruby-identifier">start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:gray</span>} <span class="ruby-comment cmt"># Open is :gray, Closed is :black</span>
260:         <span class="ruby-identifier">parent</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">k</span>}
261:         <span class="ruby-identifier">f</span> = {<span class="ruby-identifier">start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">func</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">start</span>)}
262:         <span class="ruby-identifier">queue</span> = <span class="ruby-constant">PriorityQueue</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">start</span>,<span class="ruby-identifier">f</span>[<span class="ruby-identifier">start</span>])
263:         <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">start</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block</span>
264:         
265:         <span class="ruby-comment cmt"># Process queue</span>
266:         <span class="ruby-keyword kw">until</span> <span class="ruby-identifier">queue</span>.<span class="ruby-identifier">empty?</span>
267:           <span class="ruby-identifier">u</span>,<span class="ruby-identifier">dummy</span> = <span class="ruby-identifier">queue</span>.<span class="ruby-identifier">delete_min</span>
268:           <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:examine_vertex</span>, <span class="ruby-identifier">u</span>)
269: 
270:           <span class="ruby-comment cmt"># Unravel solution if goal is reached.</span>
271:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">u</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">goal</span>
272:             <span class="ruby-identifier">solution</span> = [<span class="ruby-identifier">goal</span>]
273:             <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">u</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">start</span>
274:               <span class="ruby-identifier">solution</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">u</span>]; <span class="ruby-identifier">u</span> = <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">u</span>]
275:             <span class="ruby-keyword kw">end</span>
276:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">solution</span>.<span class="ruby-identifier">reverse</span>
277:           <span class="ruby-keyword kw">end</span>
278: 
279:           <span class="ruby-identifier">adjacent</span>(<span class="ruby-identifier">u</span>, <span class="ruby-identifier">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">:edges</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
280:             <span class="ruby-identifier">v</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">u</span> <span class="ruby-value">? </span><span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>
281:             <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:examine_edge</span>, <span class="ruby-identifier">e</span>)
282:             <span class="ruby-identifier">w</span> = <span class="ruby-identifier">cost</span>(<span class="ruby-identifier">e</span>, <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:weight</span>])
283:             <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">w</span>
284:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">d</span>[<span class="ruby-identifier">v</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> (<span class="ruby-identifier">w</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">d</span>[<span class="ruby-identifier">u</span>]) <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">d</span>[<span class="ruby-identifier">v</span>] 
285:               <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:edge_relaxed</span>, <span class="ruby-identifier">e</span>)
286:               <span class="ruby-identifier">d</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">w</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">d</span>[<span class="ruby-identifier">u</span>]
287:               <span class="ruby-identifier">f</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">d</span>[<span class="ruby-identifier">v</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">func</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">v</span>)
288:               <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">u</span>
289:               <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">color</span>[<span class="ruby-identifier">v</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">:gray</span>
290:                 <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:black_target</span>, <span class="ruby-identifier">v</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">color</span>[<span class="ruby-identifier">v</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">:black</span>
291:                 <span class="ruby-identifier">color</span>[<span class="ruby-identifier">v</span>] = <span class="ruby-identifier">:gray</span> 
292:                 <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:discover_vertex</span>, <span class="ruby-identifier">v</span>)
293:                 <span class="ruby-identifier">queue</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">v</span>, <span class="ruby-identifier">f</span>[<span class="ruby-identifier">v</span>] 
294:                 <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">v</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block</span>
295:               <span class="ruby-keyword kw">end</span>
296:             <span class="ruby-keyword kw">else</span>
297:               <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:edge_not_relaxed</span>, <span class="ruby-identifier">e</span>)
298:             <span class="ruby-keyword kw">end</span>
299:           <span class="ruby-keyword kw">end</span> <span class="ruby-comment cmt"># adjacent(u)</span>
300:           <span class="ruby-identifier">color</span>[<span class="ruby-identifier">u</span>] = <span class="ruby-identifier">:black</span>
301:           <span class="ruby-identifier">options</span>.<span class="ruby-identifier">handle_callback</span>(<span class="ruby-identifier">:finish_vertex</span>,<span class="ruby-identifier">u</span>)
302:         <span class="ruby-keyword kw">end</span> <span class="ruby-comment cmt"># queue.empty?</span>
303:                 
304:         <span class="ruby-keyword kw">nil</span> <span class="ruby-comment cmt"># failure, on fall through</span>
305:       
306:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000311" class="method-detail">
        <a name="M000311"></a>

        <div class="method-heading">
          <a href="#M000311" class="method-signature">
          <span class="method-name">best_first</span><span class="method-args">(start, goal, options, zero=0, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Best first has all the same options as astar with func set to h(v) = 0.
There is an additional option zero which should be defined to zero for the
operation &#8217;+&#8217; on the objects used in the computation of cost.
The parameter zero defaults to 0.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000311-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000311-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 312</span>
312:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">best_first</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">goal</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">zero</span>=<span class="ruby-value">0</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
313:         <span class="ruby-identifier">func</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">zero</span>}   
314:         <span class="ruby-identifier">astar</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">goal</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
315:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000301" class="method-detail">
        <a name="M000301"></a>

        <div class="method-heading">
          <a href="#M000301" class="method-signature">
          <span class="method-name">bfs</span><span class="method-args">(options={}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Options are mostly callbacks passed in as a hash. The following are valid,
anything else is ignored :enter_vertex =&gt; Proc Called upon entry of a
vertex :exit_vertex =&gt; Proc Called upon exit of a vertex :root_vertex
=&gt; Proc Called when a vertex the a root of a tree :start_vertex =&gt;
Proc Called for the first vertex of the search :examine_edge =&gt; Proc
Called when an edge is examined :tree_edge =&gt; Proc Called when the edge
is a member of the tree :back_edge =&gt; Proc Called when the edge is a
back edge :forward_edge =&gt; Proc Called when the edge is a forward edge
:adjacent =&gt; Proc that given a vertex returns adjacent nodes, defaults
to adjacent call of graph useful for changing the definition of adjacent in
some algorithms
</p>
<p>
:start =&gt; Vertex Specifies the vertex to start search from
</p>
<p>
If a &amp;block is specified it defaults to :enter_vertex
</p>
<p>
Returns the list of vertexes as reached by enter_vertex This allows for
calls like, g.bfs.each {|v| &#8230;}
</p>
<p>
Can also be called like bfs_examine_edge {|e| &#8230; } or dfs_back_edge
{|e| &#8230; } for any of the callbacks
</p>
<p>
A full example usage is as follows:
</p>
<pre>
 ev = Proc.new {|x| puts &quot;Enter Vertex #{x}&quot;}
 xv = Proc.new {|x| puts &quot;Exit Vertex #{x}&quot;}
 sv = Proc.new {|x| puts &quot;Start Vertex #{x}&quot;}
 ee = Proc.new {|x| puts &quot;Examine Arc #{x}&quot;}
 te = Proc.new {|x| puts &quot;Tree Arc #{x}&quot;}
 be = Proc.new {|x| puts &quot;Back Arc #{x}&quot;}
 fe = Proc.new {|x| puts &quot;Forward Arc #{x}&quot;}
 Digraph[1,2,2,3,3,4].dfs({
       :enter_vertex =&gt; ev,
       :exit_vertex  =&gt; xv,
       :start_vertex =&gt; sv,
       :examine_edge =&gt; ee,
       :tree_edge    =&gt; te,
       :back_edge    =&gt; be,
       :forward_edge =&gt; fe })
</pre>
<p>
Which outputs:
</p>
<p>
Start Vertex 1 Enter Vertex 1 Examine <a href="../Arc.html">Arc</a> (1=2)
Tree <a href="../Arc.html">Arc</a> (1=2) Enter Vertex 2 Examine <a
href="../Arc.html">Arc</a> (2=3) Tree <a href="../Arc.html">Arc</a> (2=3)
Enter Vertex 3 Examine <a href="../Arc.html">Arc</a> (3=4) Tree <a
href="../Arc.html">Arc</a> (3=4) Enter Vertex 4 Examine <a
href="../Arc.html">Arc</a> (1=4) Back <a href="../Arc.html">Arc</a> (1=4)
Exit Vertex 4 Exit Vertex 3 Exit Vertex 2 Exit Vertex 1
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000301-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000301-source">
<pre>
    <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 92</span>
92:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">bfs</span>(<span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-identifier">gratr_search_helper</span>(<span class="ruby-identifier">:shift</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000305" class="method-detail">
        <a name="M000305"></a>

        <div class="method-heading">
          <a href="#M000305" class="method-signature">
          <span class="method-name">bfs_spanning_forest</span><span class="method-args">(start)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the bfs spanning forest for the given start node, see <a
href="Search.html#M000303">spanning_forest</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000305-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000305-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 112</span>
112:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">bfs_spanning_forest</span>(<span class="ruby-identifier">start</span>) <span class="ruby-identifier">spanning_forest</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">:bfs</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000308" class="method-detail">
        <a name="M000308"></a>

        <div class="method-heading">
          <a href="#M000308" class="method-signature">
          <span class="method-name">bfs_tree_from_vertex</span><span class="method-args">(start)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a hash of predecessors for the depth first search tree rooted at
the given node
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000308-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000308-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 130</span>
130:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">bfs_tree_from_vertex</span>(<span class="ruby-identifier">start</span>) <span class="ruby-identifier">tree_from_vertex</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">:bfs</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000314" class="method-detail">
        <a name="M000314"></a>

        <div class="method-heading">
          <a href="#M000314" class="method-signature">
          <span class="method-name">cyclic?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns false if a graph contains no cycles, true otherwise
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000314-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000314-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 417</span>
417:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">cyclic?</span>()  <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">acyclic?</span>; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000302" class="method-detail">
        <a name="M000302"></a>

        <div class="method-heading">
          <a href="#M000302" class="method-signature">
          <span class="method-name">dfs</span><span class="method-args">(options={}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
See options for bfs method
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000302-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000302-source">
<pre>
    <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 95</span>
95:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">dfs</span>(<span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-identifier">gratr_search_helper</span>(<span class="ruby-identifier">:pop</span>,   <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000304" class="method-detail">
        <a name="M000304"></a>

        <div class="method-heading">
          <a href="#M000304" class="method-signature">
          <span class="method-name">dfs_spanning_forest</span><span class="method-args">(start)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the dfs spanning forest for the given start node, see <a
href="Search.html#M000303">spanning_forest</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000304-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000304-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 109</span>
109:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">dfs_spanning_forest</span>(<span class="ruby-identifier">start</span>) <span class="ruby-identifier">spanning_forest</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">:dfs</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000307" class="method-detail">
        <a name="M000307"></a>

        <div class="method-heading">
          <a href="#M000307" class="method-signature">
          <span class="method-name">dfs_tree_from_vertex</span><span class="method-args">(start)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a hash of predecessors for the depth first search tree rooted at
the given node
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000307-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000307-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 127</span>
127:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">dfs_tree_from_vertex</span>(<span class="ruby-identifier">start</span>) <span class="ruby-identifier">tree_from_vertex</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">:dfs</span>); <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000309" class="method-detail">
        <a name="M000309"></a>

        <div class="method-heading">
          <a href="#M000309" class="method-signature">
          <span class="method-name">lexicograph_bfs</span><span class="method-args">(&amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Lexicographic breadth-first search, the usual queue of vertices is replaced
by a queue of unordered subsets of the vertices, which is sometimes refined
but never reordered.
</p>
<p>
Originally developed by Rose, Tarjan, and Leuker, &quot;Algorithmic aspects
of vertex elimination on graphs&quot;, SIAM J. Comput. 5, 266-283 MR53
12077
</p>
<p>
Implementation taken from Golumbic&#8217;s, &quot;Algorithmic <a
href="../Graph.html">Graph</a> Theory and Perfect Graphs&quot; pg, 84-90
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000309-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000309-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 193</span>
193:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">lexicograph_bfs</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
194:         <span class="ruby-identifier">lex_q</span> = <span class="ruby-constant">GRATR</span><span class="ruby-operator">::</span><span class="ruby-constant">Graph</span><span class="ruby-operator">::</span><span class="ruby-constant">Search</span><span class="ruby-operator">::</span><span class="ruby-constant">LexicographicQueue</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">vertices</span>)
195:         <span class="ruby-identifier">result</span> = []
196:         <span class="ruby-identifier">num_vertices</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword kw">do</span>               
197:           <span class="ruby-identifier">v</span> = <span class="ruby-identifier">lex_q</span>.<span class="ruby-identifier">pop</span>
198:           <span class="ruby-identifier">result</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">v</span>)
199:           <span class="ruby-identifier">lex_q</span>.<span class="ruby-identifier">add_lexeme</span>(<span class="ruby-identifier">adjacent</span>(<span class="ruby-identifier">v</span>))            
200:         <span class="ruby-keyword kw">end</span>
201:         <span class="ruby-identifier">result</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">r</span>)} <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block</span>
202:         <span class="ruby-identifier">result</span>
203:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000303" class="method-detail">
        <a name="M000303"></a>

        <div class="method-heading">
          <a href="#M000303" class="method-signature">
          <span class="method-name">spanning_forest</span><span class="method-args">(start, routine)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Routine to compute a spanning forest for the given search method Returns
two values, first is a hash of predecessors and second an array of root
nodes
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000303-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000303-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 99</span>
 99:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">spanning_forest</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">routine</span>)
100:         <span class="ruby-identifier">predecessor</span> = {}
101:         <span class="ruby-identifier">roots</span>       = []
102:         <span class="ruby-identifier">te</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>}
103:         <span class="ruby-identifier">rv</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">roots</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">v</span>}
104:         <span class="ruby-identifier">send</span> <span class="ruby-identifier">routine</span>, <span class="ruby-identifier">:start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span>, <span class="ruby-identifier">:tree_edge</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">te</span>, <span class="ruby-identifier">:root_vertex</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">rv</span>
105:         [<span class="ruby-identifier">predecessor</span>, <span class="ruby-identifier">roots</span>]
106:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000312" class="method-detail">
        <a name="M000312"></a>

        <div class="method-heading">
          <a href="#M000312" class="method-signature">
          <span class="method-name">topsort</span><span class="method-args">(start = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Topological Sort Iterator
</p>
<p>
The topological sort algorithm creates a linear ordering of the vertices
such that if edge (u,v) appears in the graph, then u comes before v in the
ordering. The graph must be a directed acyclic graph (DAG).
</p>
<p>
The iterator can also be applied to undirected graph or to a DG graph which
contains a cycle. In this case, the Iterator does not reach all vertices.
The implementation of acyclic? and cyclic? uses this fact.
</p>
<p>
Can be called with a block as a standard Ruby iterator, or it can be used
directly as it will return the result as an Array
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000312-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000312-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 403</span>
403:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">topsort</span>(<span class="ruby-identifier">start</span> = <span class="ruby-keyword kw">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
404:         <span class="ruby-identifier">result</span>  = []
405:         <span class="ruby-identifier">go</span>      = <span class="ruby-keyword kw">true</span> 
406:         <span class="ruby-identifier">back</span>    = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">go</span> = <span class="ruby-keyword kw">false</span> } 
407:         <span class="ruby-identifier">push</span>    = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">v</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">go</span>}
408:         <span class="ruby-identifier">start</span>   <span class="ruby-operator">||=</span> <span class="ruby-identifier">vertices</span>[<span class="ruby-value">0</span>]
409:         <span class="ruby-identifier">dfs</span>({<span class="ruby-identifier">:exit_vertex</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">push</span>, <span class="ruby-identifier">:back_edge</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">back</span>, <span class="ruby-identifier">:start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span>})
410:         <span class="ruby-identifier">result</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">v</span>)} <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block</span>; <span class="ruby-identifier">result</span>
411:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000306" class="method-detail">
        <a name="M000306"></a>

        <div class="method-heading">
          <a href="#M000306" class="method-signature">
          <span class="method-name">tree_from_vertex</span><span class="method-args">(start, routine)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a hash of predecessors in a tree rooted at the start node. If this
is a connected graph then it will be a spanning tree and contain all
vertices. An easier way to tell if it&#8217;s a spanning tree is to use a
<a href="Search.html#M000303">spanning_forest</a> call and check if there
is a single root node.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000306-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000306-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/search.rb, line 117</span>
117:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tree_from_vertex</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">routine</span>)
118:         <span class="ruby-identifier">predecessor</span>={}
119:         <span class="ruby-identifier">correct_tree</span> = <span class="ruby-keyword kw">false</span>
120:         <span class="ruby-identifier">te</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">correct_tree</span>}
121:         <span class="ruby-identifier">rv</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">correct_tree</span> = (<span class="ruby-identifier">v</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">start</span>)}
122:         <span class="ruby-identifier">send</span> <span class="ruby-identifier">routine</span>, <span class="ruby-identifier">:start</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span>, <span class="ruby-identifier">:tree_edge</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">te</span>, <span class="ruby-identifier">:root_vertex</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">rv</span>
123:         <span class="ruby-identifier">predecessor</span>       
124:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>