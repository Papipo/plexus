<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: GRATR::Graph::Biconnected</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">GRATR::Graph::Biconnected</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/gratr/biconnected_rb.html">
                lib/gratr/biconnected.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="Biconnected.html">Biconnected</a> is a module for adding the
biconnected algorithm to UndirectedGraphs
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000319">biconnected</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000319" class="method-detail">
        <a name="M000319"></a>

        <div class="method-heading">
          <a href="#M000319" class="method-signature">
          <span class="method-name">biconnected</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
biconnected computes the biconnected subgraphs of a graph using
Tarjan&#8217;s algorithm based on DFS. See: Robert E. Tarjan
<em>Depth_First_Search_and_Linear_Graph_Algorithms</em>. SIAM Journal on
Computing, 1(2):146-160, 1972
</p>
<p>
The output of the algorithm is a pair, the first value is an array of
biconnected subgraphs. The second is the set of articulation vertices.
</p>
<p>
A connected graph is biconnected if the removal of any single vertex (and
all edges incident on that vertex) cannot disconnect the graph. More
generally, the biconnected components of a graph are the maximal subsets of
vertices such that the removal of a vertex from a particular component will
not disconnect the component. Unlike connected components, vertices may
belong to multiple biconnected components: those vertices that belong to
more than one biconnected component are called articulation points or,
equivalently, cut vertices. Articulation points are vertices whose removal
would increase the number of connected components in the graph. Thus, a
graph without articulation points is biconnected.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000319-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000319-source">
<pre>
     <span class="ruby-comment cmt"># File lib/gratr/biconnected.rb, line 56</span>
 56:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">biconnected</span>
 57:         <span class="ruby-identifier">dfs_num</span>     = <span class="ruby-value">0</span>
 58:         <span class="ruby-identifier">number</span>      = {}; <span class="ruby-identifier">predecessor</span> = {}; <span class="ruby-identifier">low_point</span>   = {}
 59:         <span class="ruby-identifier">stack</span>       = []; <span class="ruby-identifier">result</span>      = []; <span class="ruby-identifier">articulation</span>= []
 60: 
 61:         <span class="ruby-identifier">root_vertex</span>  = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">v</span>]=<span class="ruby-identifier">v</span> }
 62:         <span class="ruby-identifier">enter_vertex</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">u</span><span class="ruby-operator">|</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">u</span>]=<span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">u</span>]=(<span class="ruby-identifier">dfs_num</span><span class="ruby-operator">+=</span><span class="ruby-value">1</span>) }
 63:         <span class="ruby-identifier">tree_edge</span>  = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
 64:           <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">e</span>)
 65:           <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>] = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>
 66:         <span class="ruby-keyword kw">end</span>
 67:         <span class="ruby-identifier">back_edge</span>  = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
 68:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>]
 69:             <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">e</span>)
 70:             <span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>] = [<span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">source</span>], <span class="ruby-identifier">number</span>[<span class="ruby-identifier">e</span>.<span class="ruby-identifier">target</span>]].<span class="ruby-identifier">min</span>
 71:           <span class="ruby-keyword kw">end</span>
 72:         <span class="ruby-keyword kw">end</span>
 73:         <span class="ruby-identifier">exit_vertex</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">u</span><span class="ruby-operator">|</span>
 74:           <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">u</span>]
 75:           <span class="ruby-identifier">is_articulation_point</span> = <span class="ruby-keyword kw">false</span>
 76:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">parent</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">u</span>]
 77:             <span class="ruby-identifier">parent</span> = <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">parent</span>]
 78:             <span class="ruby-identifier">is_articulation_point</span> = <span class="ruby-keyword kw">true</span>
 79:           <span class="ruby-keyword kw">end</span>
 80:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">parent</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">u</span>
 81:             <span class="ruby-identifier">is_articulation_point</span> = <span class="ruby-keyword kw">false</span> <span class="ruby-keyword kw">if</span> (<span class="ruby-identifier">number</span>[<span class="ruby-identifier">u</span>] <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">u</span>]]
 82:           <span class="ruby-keyword kw">else</span>
 83:             <span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">parent</span>] = [<span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">parent</span>], <span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">u</span>]].<span class="ruby-identifier">min</span>
 84:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">low_point</span>[<span class="ruby-identifier">u</span>] <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">parent</span>]
 85:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">parent</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">parent</span>]]
 86:                 <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">u</span>] = <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">parent</span>]
 87:                 <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">u</span>
 88:               <span class="ruby-keyword kw">end</span>
 89:               <span class="ruby-identifier">result</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">component</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">new</span>)
 90:               <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">stack</span>[<span class="ruby-value">-1</span>].<span class="ruby-identifier">source</span>] <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">number</span>[<span class="ruby-identifier">u</span>]
 91:                 <span class="ruby-identifier">component</span>.<span class="ruby-identifier">add_edge!</span>(<span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>)
 92:               <span class="ruby-keyword kw">end</span>
 93:               <span class="ruby-identifier">component</span>.<span class="ruby-identifier">add_edge!</span>(<span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>)
 94:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">empty?</span>
 95:                 <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">u</span>] = <span class="ruby-identifier">parent</span>
 96:                 <span class="ruby-identifier">predecessor</span>[<span class="ruby-identifier">parent</span>] = <span class="ruby-identifier">u</span>
 97:               <span class="ruby-keyword kw">end</span>
 98:             <span class="ruby-keyword kw">end</span>
 99:           <span class="ruby-keyword kw">end</span>
100:           <span class="ruby-identifier">articulation</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">u</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">is_articulation_point</span>
101:         <span class="ruby-keyword kw">end</span>
102: 
103:         <span class="ruby-comment cmt"># Execute depth first search</span>
104:         <span class="ruby-identifier">dfs</span>({<span class="ruby-identifier">:root_vertex</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">root_vertex</span>,
105:              <span class="ruby-identifier">:enter_vertex</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">enter_vertex</span>, 
106:              <span class="ruby-identifier">:tree_edge</span>    =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">tree_edge</span>,
107:              <span class="ruby-identifier">:back_edge</span>    =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">back_edge</span>,
108:              <span class="ruby-identifier">:exit_vertex</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">exit_vertex</span>})
109:            
110:         [<span class="ruby-identifier">result</span>, <span class="ruby-identifier">articulation</span>]
111:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>